using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace Testing.TestRunner
{
	/// <summary>
	/// The result and other information generated by a test.
	/// </summary>
	public sealed class TestResult 
	{
		private StringBuilder _message;
		private StringBuilder _output;
		private TestStatus _status;
		private string _stackTrace;
		private long _timeSpan;

		/// <summary>
		/// Creates a new TestResult.
		/// </summary>
		public TestResult()
		{
			Reset();
		}

		/// <summary>
		/// Gets or sets the outcome status of the test.
		/// </summary>
		public TestStatus Status
		{
			get { return _status; }
			set { _status = value; }
		}
		/// <summary>
		/// Gets a string builder used to store a description of the test outcome.
		/// </summary>
		public StringBuilder Message
		{
			get { return _message; }
		}
		/// <summary>
		/// Gets a string builder used to store any extra information which maybe helpful.
		/// </summary>
		public StringBuilder Output
		{
			get { return _output; }
		}

		/// <summary>
		/// Gets or sets a stack trace of an exception, if one occured.
		/// </summary>
		public string StackTrace
		{
			get { return _stackTrace; }
			set { _stackTrace = value; }
		}

		/// <summary>
		/// Gets or sets the time taken to run the test in ticks.
		/// </summary>
		public long TimeSpan
		{
			get { return _timeSpan; }
			set { _timeSpan = value; }
		}

		/// <summary>
		/// Sets the stack trace, but hides all references to "Testing".
		/// </summary>
		internal void SetFilteredStackTrace( string stackTrace )
		{
#if Test
			_stackTrace = stackTrace;
#else
			SetFilteredStackTrace( stackTrace, "Testing" );
#endif
		}

		/// <summary>
		/// Sets the stack trace, but hides all references to the supplied namespace.
		/// </summary>
		public void SetFilteredStackTrace( string stackTrace, string nspace )
		{
			Regex findNamespace = new Regex( String.Concat( "(?<=\\W)", nspace, "(?=\\W)" ) );
			MatchCollection matches = findNamespace.Matches( stackTrace );
			if( matches.Count > 0 )
			{
				int last = matches[matches.Count - 1].Index;
				// make sure it's present
				int line = stackTrace.IndexOf( "   at", last );
				// make sure it's present
				if( line > -1 && line > last && line < stackTrace.Length )
				{
					_stackTrace = stackTrace.Substring( line, stackTrace.Length - line );
				}
				else
				{
					_stackTrace = stackTrace;
				}
			}
			else
			{
				_stackTrace = stackTrace;
			}
		}

		/// <summary>
		/// Resets the state of the test result.
		/// </summary>
		public void Reset()
		{
			_status = TestStatus.Untested;
			_message = new StringBuilder();
			_output = new StringBuilder();
			_stackTrace = null;
			_timeSpan = 0;
		}

		/// <summary>
		/// Helper method to consistently format an exception to output.
		/// </summary>
		internal void WriteExceptionToOutput( Exception exp )
		{
			this.Output.AppendLine( exp.Message );
			this.Output.Append( "EXCEPTION TYPE: " );
			this.Output.AppendLine( exp.GetType().FullName );
			this.Output.Append( "STACK TRACE: " );
			this.Output.AppendLine( exp.StackTrace );
		}

		/// <summary>
		/// Helper method to consistently format an exception to message.
		/// </summary>
		internal void WriteExceptionToMessage( Exception exp )
		{
			this.Message.Append( "EXCEPTION MESSAGE: " );
			this.Message.AppendLine( exp.Message );
			this.Message.Append( "EXCEPTION TYPE: " );
			this.Message.AppendLine( exp.GetType().FullName );
			this.Message.Append( "STACK TRACE: " );
			this.Message.AppendLine( exp.StackTrace );
		}

		/// <summary>
		/// Helper method to consistently format an ignore to message.
		/// </summary>
		internal void WriteIgnoreToMessage( ITest test, string ignoreReason )
		{
			// TODO move this satus change.
			test.Result.Status = TestStatus.Ignore;
			if( ignoreReason != null )
			{
				test.Result.Message.AppendFormat( "{0} - {1}\n", test.Name, ignoreReason );
			}
			else
			{
				test.Result.Message.AppendFormat( "{0}\n", test.Name );
			}
		}
	}
}
